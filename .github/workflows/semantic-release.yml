name: Semantic Release Workflow

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'skip ci')"
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.TEST_TOKEN }}
        
    - name: Set up Git
      run: |
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
       
    - name: Set execute permissions for Gradle wrapper
      run: chmod +x ./gradlew

    - name: Setup Development Environment
      run: ./gradlew devSetup

    - name: Validate API Before Release
      run: ./gradlew apiValidate

    - name: Generate API Documentation
      run: ./gradlew apiDocs

    - name: Determine version increment
      id: version
      run: |
        # Get the latest version tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        # Strip the 'v' prefix
        LATEST_VERSION=${LATEST_TAG#v}
        
        # Split version into components
        IFS='.' read -r -a VERSION_PARTS <<< "$LATEST_VERSION"
        MAJOR=${VERSION_PARTS[0]:-0}
        MINOR=${VERSION_PARTS[1]:-0}
        PATCH=${VERSION_PARTS[2]:-0}
        
        # Get all commit messages since the last tag
        echo "Analyzing commits since tag $LATEST_TAG"
        if [ "$LATEST_TAG" = "v0.0.0" ] || ! git tag | grep -q "$LATEST_TAG"; then
          # No previous tags, analyze all commits
          COMMITS=$(git log --pretty=format:"%s")
          echo "üìù Analyzing all commits (no previous tags)"
        else
          COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s")
          echo "üìù Analyzing commits since $LATEST_TAG"
        fi
        
        echo "Commits found:"
        echo "$COMMITS"
        
        # Initialize flags
        NEED_MAJOR=false
        NEED_MINOR=false
        NEED_PATCH=false
        HAS_BREAKING=false
        
        # Analyze each commit
        echo "Analyzing commit types..."
        while IFS= read -r commit; do
          [ -z "$commit" ] && continue
          echo "Analyzing: $commit"
          
          # Check for breaking changes - FIX: Simplified regex patterns
          if [[ $commit == *"!"*":"* ]] || [[ $commit == *"BREAKING CHANGE"* ]]; then
            echo "  - ‚ö†Ô∏è Breaking change detected"
            NEED_MAJOR=true
            HAS_BREAKING=true
          elif [[ $commit == feat:* ]] || [[ $commit == feat\(*\):* ]]; then
            echo "  - ‚ú® Feature detected"
            NEED_MINOR=true
          elif [[ $commit == fix:* ]] || [[ $commit == fix\(*\):* ]]; then
            echo "  - üêõ Fix detected"
            NEED_PATCH=true
          elif [[ $commit == docs:* ]] || [[ $commit == docs\(*\):* ]] || \
              [[ $commit == style:* ]] || [[ $commit == style\(*\):* ]] || \
              [[ $commit == refactor:* ]] || [[ $commit == refactor\(*\):* ]] || \
              [[ $commit == perf:* ]] || [[ $commit == perf\(*\):* ]] || \
              [[ $commit == test:* ]] || [[ $commit == test\(*\):* ]] || \
              [[ $commit == chore:* ]] || [[ $commit == chore\(*\):* ]] || \
              [[ $commit == build:* ]] || [[ $commit == build\(*\):* ]] || \
              [[ $commit == ci:* ]] || [[ $commit == ci\(*\):* ]]; then
            echo "  - üîß Maintenance change detected"
            NEED_PATCH=true
          else
            echo "  - ‚ùì Non-conventional commit (treated as patch)"
            NEED_PATCH=true
          fi
        done <<< "$COMMITS"
        
        # Special handling for initial development (0.x.x)
        if [ "$MAJOR" -eq 0 ]; then
          echo "üìã Currently in initial development phase (0.x.x)"
          echo "::notice::API is not considered stable - SemVer rules adjusted"
          
          # In 0.x.x, breaking changes increment MINOR instead of MAJOR
          if [ "$NEED_MAJOR" = true ] || [ "$NEED_MINOR" = true ]; then
            echo "Incrementing MINOR version (breaking changes or features in 0.x.x)"
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [ "$NEED_PATCH" = true ]; then
            echo "Incrementing PATCH version"
            PATCH=$((PATCH + 1))
          else
            echo "No releasable changes found"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if it's time to go to 1.0.0
          if [ "$MINOR" -ge 10 ]; then
            echo "::notice::Consider releasing version 1.0.0 to indicate API stability"
          fi
        else
          # Standard SemVer logic for stable versions (1.x.x+)
          echo "üìã Using standard SemVer logic for stable version"
          
          if [ "$NEED_MAJOR" = true ]; then
            echo "üö® Breaking changes found - incrementing MAJOR version"
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$NEED_MINOR" = true ]; then
            echo "‚ú® Features found - incrementing MINOR version"
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [ "$NEED_PATCH" = true ]; then
            echo "üêõ Fixes or other changes found - incrementing PATCH version"
            PATCH=$((PATCH + 1))
          else
            echo "No releasable changes found"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        
        # Output results
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "previous_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "has_breaking_changes=$HAS_BREAKING" >> $GITHUB_OUTPUT
        echo "is_initial_development=$([ "$MAJOR" -eq 0 ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
        
        echo "üéØ New version will be: v$NEW_VERSION"
        
        if [ "$HAS_BREAKING" = true ]; then
          if [ "$MAJOR" -eq 0 ]; then
            echo "‚ö†Ô∏è Breaking changes in initial development version"
          else
            echo "üö® Breaking changes in stable version - MAJOR bump"
          fi
        fi
        
    - name: Create Release Notes
      if: steps.version.outputs.skip_release != 'true'
      id: release_notes
      run: |
        echo "Generating release notes..."
        
        # Categorize commits
        FEAT_COMMITS=""
        FIX_COMMITS=""
        BREAKING_COMMITS=""
        OTHER_COMMITS=""
        
        if [ "${{ steps.version.outputs.previous_tag }}" = "v0.1.0" ] && ! git tag | grep -q "v0.1.0"; then
          COMMITS=$(git log --pretty=format:"%s")
        else
          COMMITS=$(git log ${{ steps.version.outputs.previous_tag }}..HEAD --pretty=format:"%s")
        fi
        
        while IFS= read -r commit; do
          [ -z "$commit" ] && continue
          if [[ $commit =~ ^[a-zA-Z]+(\([^)]*\))?!: ]] || [[ $commit == *"BREAKING CHANGE"* ]]; then
            BREAKING_COMMITS="$BREAKING_COMMITS\n- $commit"
          elif [[ $commit =~ ^feat(\([^)]*\))?: ]]; then
            FEAT_COMMITS="$FEAT_COMMITS\n- ${commit#feat*: }"
          elif [[ $commit =~ ^fix(\([^)]*\))?: ]]; then
            FIX_COMMITS="$FIX_COMMITS\n- ${commit#fix*: }"
          else
            OTHER_COMMITS="$OTHER_COMMITS\n- $commit"
          fi
        done <<< "$COMMITS"
        
        # Create release notes
        NOTES="# Release v${{ steps.version.outputs.new_version }}

        ## üöÄ Akka Cluster Docker Swarm Project

        Automated release for the university project implementing Akka clustering with Docker Swarm.

        ## üì¶ Docker Images

        This release includes the following Docker images:
        - \`brunoesposito2/akka-node1:${{ steps.version.outputs.new_version }}\`
        - \`brunoesposito2/akka-node2:${{ steps.version.outputs.new_version }}\`

        ## üîß Quick Deployment

        \`\`\`bash
        # Download the deployment script
        curl -sSL https://github.com/brunoesposito2/DockerSwarmAkka/releases/download/v${VERSION}/deploy-akka.sh -o deploy-akka.sh
        chmod +x deploy-akka.sh
        
        # Run the script with the specified version
        ./deploy-akka.sh ${VERSION}

        \`\`\`

        ## üìã Changes"
                
                if [ -n "$BREAKING_COMMITS" ]; then
                  NOTES="$NOTES

        ### ‚ö†Ô∏è BREAKING CHANGES
        $BREAKING_COMMITS"
                fi
                
                if [ -n "$FEAT_COMMITS" ]; then
                  NOTES="$NOTES

        ### ‚ú® New Features
        $FEAT_COMMITS"
                fi
                
                if [ -n "$FIX_COMMITS" ]; then
                  NOTES="$NOTES

        ### üêõ Bug Fixes
        $FIX_COMMITS"
                fi
                
                if [ -n "$OTHER_COMMITS" ]; then
                  NOTES="$NOTES

        ### üîß Other Changes
        $OTHER_COMMITS"
                fi
                
                NOTES="$NOTES

        ## üéì Academic Context

        This project demonstrates:
        - Akka Actor Model implementation
        - Distributed systems with clustering
        - Docker containerization and orchestration
        - CI/CD with semantic versioning
        - Infrastructure as Code principles

        [Full Changelog](https://github.com/${{ github.repository }}/compare/${{ steps.version.outputs.previous_tag }}...v${{ steps.version.outputs.new_version }})"
                
        # Save notes to file for GitHub release
        echo "$NOTES" > release_notes.md
        
    - name: Prepare Production Docker Compose # sostituirlo con qualcosa che va a prendere il docker compose di produzione 
                                        # e lo modifica aggiornando solo la versione delle immagini da considerare
      run: |
        VERSION=${{ steps.version.outputs.new_version }}
        mkdir -p release-artifacts
        
        # Create a Docker Compose file with the new version
        cat > release-artifacts/docker-compose-${VERSION}.yml << EOF
        version: '3.8'

        services:
          worker1:
            image: brunoesposito2/akka-node1:${VERSION}
            privileged: true
            container_name: worker1
            ports:
              - "2555:2555"
            environment:
              - JOIN_TOKEN=${JOIN_TOKEN}
              - MANAGER_IP=${MANAGER_IP}
            volumes:
              - worker1-certs:/certs
            networks:
              - swarm-network
            restart: always
            deploy:
              mode: replicated
              replicas: 1
        
          worker2:
            image: brunoesposito2/akka-node2:${VERSION}
            privileged: true
            container_name: worker2
            ports:
              - "2551:2551"
            environment:
              - JOIN_TOKEN=${JOIN_TOKEN}
              - MANAGER_IP=${MANAGER_IP}
            volumes:
              - worker2-certs:/certs
            networks:
              - swarm-network
            restart: always
            deploy:
              mode: replicated
              replicas: 1
        
        volumes:
          worker1-certs:
          worker2-certs:
        
        networks:
          swarm-network:
            driver: overlay
            attachable: true
        EOF
        
    - name: Create Deployment Script
      run: |
        VERSION=${{ steps.version.outputs.new_version }}
        
        # Create deployment script
        cat > release-artifacts/deploy-akka.sh << 'EOF'
        #!/bin/bash
        
        # AKKA Production Deployment Script
        # Questo script automatizza il deployment di AKKA usando Docker Swarm
        
        # Colori per l'output
        GREEN='\033[0;32m'
        RED='\033[0;31m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        NC='\033[0m' # No Color
        
        # Configurazione 
        VERSION=$1
        ORGANIZATION="brunoesposito2"
        
        if [ -z "$VERSION" ]; then
            echo -e "${YELLOW}Nessuna versione specificata, utilizzo 'latest'${NC}"
            VERSION="latest"
        fi
        
        echo -e "${BLUE}=== AKKA Deployment Script - Versione $VERSION ===${NC}"
        
        # Verifica se docker √® installato
        if ! command -v docker &> /dev/null; then
            echo -e "${RED}Docker non √® installato. Per favore installa Docker prima di continuare.${NC}"
            exit 1
        fi
        
        # Verifica se lo swarm √® gi√† inizializzato
        swarm_status=$(docker info --format '{{.Swarm.LocalNodeState}}' 2>/dev/null)
        if [ "$swarm_status" != "active" ]; then
            echo -e "${YELLOW}Inizializzazione Docker Swarm...${NC}"
            docker swarm init || { 
                echo -e "${RED}Errore durante l'inizializzazione dello swarm${NC}"
                echo -e "${YELLOW}Provo con l'opzione --advertise-addr${NC}"
                
                # Ottieni l'indirizzo IP predefinito
                DEFAULT_IP=$(hostname -I | awk '{print $1}')
                docker swarm init --advertise-addr $DEFAULT_IP || {
                    echo -e "${RED}Inizializzazione swarm fallita. Verifica la tua configurazione di rete.${NC}"
                    exit 1
                }
            }
        else
            echo -e "${GREEN}Docker Swarm √® gi√† attivo.${NC}"
        fi
        
        # Ottieni il token di join per i worker
        JOIN_TOKEN=$(docker swarm join-token -q worker)
        echo -e "${GREEN}Token di join dello swarm: $JOIN_TOKEN${NC}"
        
        # Ottieni l'IP del manager
        MANAGER_IP=$(docker node inspect self --format '{{.Status.Addr}}')
        echo -e "${GREEN}IP del manager: $MANAGER_IP${NC}"
        
        # Crea la rete overlay se non esiste
        if ! docker network ls | grep -q "swarm-network"; then
            echo -e "${YELLOW}Creazione rete overlay 'swarm-network'...${NC}"
            docker network create --driver overlay --attachable swarm-network || { 
                echo -e "${RED}Errore durante la creazione della rete${NC}"
                exit 1
            }
        else
            echo -e "${GREEN}Rete 'swarm-network' gi√† presente.${NC}"
        fi
        
        # Scarica il docker-compose file
        echo -e "${YELLOW}Scaricamento del file docker-compose...${NC}"
        COMPOSE_URL="https://github.com/brunoesposito2/DockerSwarmAkka/releases/download/v${VERSION}/docker-compose-${VERSION}.yml"
        COMPOSE_FILE="docker-compose-${VERSION}.yml"
        
        if curl -sSL "$COMPOSE_URL" -o "$COMPOSE_FILE"; then
            echo -e "${GREEN}File docker-compose scaricato con successo.${NC}"
        else
            echo -e "${RED}Impossibile scaricare il file docker-compose. Verificando localmente...${NC}"
            if [ ! -f "$COMPOSE_FILE" ]; then
                echo -e "${RED}File '$COMPOSE_FILE' non trovato. Scarica il file manualmente dalla pagina delle release GitHub.${NC}"
                exit 1
            else
                echo -e "${GREEN}Utilizzando il file docker-compose locale.${NC}"
            fi
        fi
        
        # Export delle variabili d'ambiente necessarie
        export JOIN_TOKEN=$JOIN_TOKEN
        export MANAGER_IP=$MANAGER_IP
        
        # Verifica se ci sono stack esistenti e li rimuove
        if docker stack ls | grep -q "akka"; then
            echo -e "${YELLOW}Trovato stack AKKA esistente. Rimozione...${NC}"
            docker stack rm akka
            echo -e "${YELLOW}Attesa per la rimozione completa dello stack...${NC}"
            sleep 15  # Attendi che lo stack venga rimosso completamente
        fi
        
        # Deploy dello stack
        echo -e "${YELLOW}Deploying AKKA stack...${NC}"
        docker stack deploy -c "$COMPOSE_FILE" akka || {
            echo -e "${RED}Errore durante il deployment dello stack.${NC}"
            exit 1
        }
        
        # Verifica che tutti i servizi siano avviati
        echo -e "${YELLOW}Verifica dello stato dei servizi...${NC}"
        sleep 5  # Attendi che i servizi inizino
        docker stack services akka
        
        echo -e "${GREEN}=== Deployment completato! ===${NC}"
        echo -e "${BLUE}Per visualizzare i log, esegui: docker service logs -f <service_name>${NC}"
        echo -e "${BLUE}Per monitorare i servizi, esegui: docker stack services akka${NC}"
        echo -e "${BLUE}L'interfaccia web sar√† disponibile su: http://localhost:3000${NC}"
        EOF
        
        chmod +x release-artifacts/deploy-akka.sh
        
    - name: Create README for Release
      run: |
        VERSION=${{ steps.version.outputs.new_version }}
        
        # Create README file
        cat > release-artifacts/README.md << EOF
        # AKKA Release v${VERSION}
        
        ## Deployment rapido
        
        Il modo pi√π semplice per deployare questa release √® utilizzare lo script di deployment:
        
        \`\`\`bash
        # Scarica lo script di deployment
        curl -sSL https://github.com/brunoesposito2/DockerSwarmAkka/releases/download/v${VERSION}/deploy-akka.sh -o deploy-akka.sh
        chmod +x deploy-akka.sh
        
        # Esegui lo script con la versione specifica
        ./deploy-akka.sh ${VERSION}
        \`\`\`
        
        ## Deployment manuale con Docker Swarm
        
        1. Inizializza lo swarm:
        \`\`\`bash
        docker swarm init
        \`\`\`
        
        2. Ottieni il token:
        \`\`\`bash
        export JOIN_TOKEN=$(docker swarm join-token -q worker)
        \`\`\`
        
        3. Ottieni l'IP del manager:
        \`\`\`bash
        export MANAGER_IP=$(docker node inspect self --format '{{.Status.Addr}}')
        \`\`\`
        
        4. Esegui lo stack:
        \`\`\`bash
        docker stack deploy -c docker-compose-${VERSION}.yml akka
        \`\`\`
        
        ## Immagini Docker
        
        Le seguenti immagini Docker sono disponibili per questa release:
        
        \`\`\`
        brunoesposito2/akka-node1:${VERSION}
        brunoesposito2/akka-node2:${VERSION}
        \`\`\`
        EOF
        
    - name: Create Release and Trigger Docker Build # triggerare l'action docker-publish prima di fare la release 
      id: create_release
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.TEST_TOKEN }}
      with:
        tag_name: v${{ steps.version.outputs.new_version }}
        name: Release v${{ steps.version.outputs.new_version }}
        draft: false
        prerelease: false
        body: ${{ steps.release_notes.outputs.content }}
        
    - name: Update version in project # Nota (da fare in generale, non qui): aggiungere la parte di versione nel build.gradle di ogni file di progetto 
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"
        
        # Update version in gradle.properties
        if [ -f "gradle.properties" ]; then
          # Replace the version line instead of appending
          sed -i "s/^version=.*/version=$NEW_VERSION/" gradle.properties
          
          # Commit the version change
          git add gradle.properties
          git commit -m "chore: bump version to v$NEW_VERSION [skip ci]"
          git push
        fi

    - name: Add Release Artifacts
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.new_version }}
        files: |
          release-artifacts/docker-compose-${{ steps.version.outputs.new_version }}.yml
          release-artifacts/README.md
          release-artifacts/deploy-akka.sh
      env:
        GITHUB_TOKEN: ${{ secrets.TEST_TOKEN }}

    - name: Upload API Documentation
      uses: actions/upload-artifact@v4
      with:
        name: api-documentation
        path: docs/api/generated/

    - name: Commit Updated Documentation
      if: steps.version.outputs.skip_release != 'true'
      run: |
        echo "üìù Checking for documentation updates..."
        
        if [ -d "docs/api/generated" ] && [ "$(ls -A docs/api/generated 2>/dev/null)" ]; then
          if ! git diff --quiet docs/api/generated/ 2>/dev/null; then
            echo "üìö Documentation changes detected, committing..."
            git add docs/api/generated/
            git commit -m "docs: update API documentation for v${{ steps.version.outputs.new_version }}

        [skip ci]

        - Updated message protocols documentation  
        - Updated Docker services documentation
        - Auto-generated from release v${{ steps.version.outputs.new_version }}"
                    git push
                    echo "‚úÖ Documentation committed and pushed"
                  else
                    echo "üìÑ Documentation unchanged, no commit needed"
                  fi
                else
                  echo "‚ö†Ô∏è No generated documentation found"
                fi