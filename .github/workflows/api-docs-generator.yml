# .github/workflows/api-docs-generator.yml
name: Generate API Documentation

on:
  workflow_run:
    workflows: ["Semantic Release Workflow"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:  # Permette trigger manuale

permissions:
  contents: write  # Necessario per commit delle modifiche
  pull-requests: write

jobs:
  generate-api-docs:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        distribution: 'corretto'
        java-version: '17'

    - name: Get version info
      id: version
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")
        VERSION=${LATEST_TAG#v}
        MAJOR_VERSION=$(echo $VERSION | cut -d. -f1)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "major_version=$MAJOR_VERSION" >> $GITHUB_OUTPUT
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Generated for version: $VERSION (major: $MAJOR_VERSION)"
        
    - name: Set execute permissions for gradlew
      run: chmod +x ./gradlew

    - name: Setup documentation structure
      run: |
        # Crea la struttura per la documentazione API
        mkdir -p api/v${{ steps.version.outputs.major_version }}/scala
        mkdir -p api/v${{ steps.version.outputs.major_version }}/docker

    - name: Generate Scaladoc for Both Nodes
      run: |
        echo "Generating Scaladoc for both Node1 and Node2..."
        
        # Generate Scaladoc for both nodes
        ./gradlew node1:scaladoc node2:scaladoc -PincludePackages="org.example.api"
        
        # Setup directory structure for both nodes
        mkdir -p api/v${{ steps.version.outputs.major_version }}/scala/node1
        mkdir -p api/v${{ steps.version.outputs.major_version }}/scala/node2
        mkdir -p api/v${{ steps.version.outputs.major_version }}/scala/shared
        
        # Track generation status
        NODE1_GENERATED=false
        NODE2_GENERATED=false
        
        # Copy Node1 Scaladoc
        if [ -d "node1/build/docs/scaladoc" ] && [ "$(ls -A node1/build/docs/scaladoc 2>/dev/null)" ]; then
          echo "âœ… Scaladoc generated for Node1"
          cp -r node1/build/docs/scaladoc/* api/v${{ steps.version.outputs.major_version }}/scala/node1/
          NODE1_GENERATED=true
        else
          echo "âš ï¸ Scaladoc not generated for Node1"
        fi
        
        # Copy Node2 Scaladoc
        if [ -d "node2/build/docs/scaladoc" ] && [ "$(ls -A node2/build/docs/scaladoc 2>/dev/null)" ]; then
          echo "âœ… Scaladoc generated for Node2"
          cp -r node2/build/docs/scaladoc/* api/v${{ steps.version.outputs.major_version }}/scala/node2/
          NODE2_GENERATED=true
        else
          echo "âš ï¸ Scaladoc not generated for Node2"
        fi
        
        # Create shared API documentation (using Node1 as reference for public API)
        if [ "$NODE1_GENERATED" = true ]; then
          echo "ðŸ“š Creating shared API documentation from Node1"
          cp -r node1/build/docs/scaladoc/* api/v${{ steps.version.outputs.major_version }}/scala/shared/
        elif [ "$NODE2_GENERATED" = true ]; then
          echo "ðŸ“š Creating shared API documentation from Node2"
          cp -r node2/build/docs/scaladoc/* api/v${{ steps.version.outputs.major_version }}/scala/shared/
        fi
        
        # Create main Scala API index page
        cat > api/v${{ steps.version.outputs.major_version }}/scala/index.md << EOF
        ---
        layout: default
        title: Scala API v${{ steps.version.outputs.major_version }}
        ---
        
        # Scala API Documentation v${{ steps.version.outputs.major_version }}
        
        **Version:** ${{ steps.version.outputs.version }}  
        **Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        
        ## Documentation Overview
        
        This section contains the complete Scala API documentation for the Akka cluster project, organized by node implementation.
        
        ## Available Documentation
        
        ### ðŸ“¦ Shared Public API
        - [**Public API Documentation**](./shared/) - Common interfaces and protocols
          - Message protocol definitions (Ping, Pong)
          - Service discovery keys (PingServiceKey, PongServiceKey)
          - Shared interfaces used by both nodes
        
        ### ðŸ”§ Node-Specific Implementations
        EOF
        
        if [ "$NODE1_GENERATED" = true ]; then
          cat >> api/v${{ steps.version.outputs.major_version }}/scala/index.md << EOF
        - [**Node1 Documentation**](./node1/) - Primary cluster node implementation
          - Worker1 actor implementation
          - Node1-specific configuration and behavior
          - Ping service implementation
        EOF
        else
          cat >> api/v${{ steps.version.outputs.major_version }}/scala/index.md << EOF
        - **Node1 Documentation** - âš ï¸ Generation failed
        EOF
        fi
        
        if [ "$NODE2_GENERATED" = true ]; then
          cat >> api/v${{ steps.version.outputs.major_version }}/scala/index.md << EOF
        - [**Node2 Documentation**](./node2/) - Secondary cluster node implementation
          - Worker2 actor implementation
          - Node2-specific configuration and behavior
          - Pong service implementation
        EOF
        else
          cat >> api/v${{ steps.version.outputs.major_version }}/scala/index.md << EOF
        - **Node2 Documentation** - âš ï¸ Generation failed
        EOF
        fi
        
        cat >> api/v${{ steps.version.outputs.major_version }}/scala/index.md << EOF
        
        ## Public API Packages
        
        The following packages are part of the **stable public API**:
        
        - **org.example.api.protocol** - Message protocol definitions
        - **org.example.api.discovery** - Service discovery keys
        
        ## Key Components
        
        ### Message Protocol
        \`\`\`scala
        // Base message trait
        trait Message
        
        // Ping-Pong protocol
        case class Ping(replyTo: ActorRef[Pong]) extends Message
        case class Pong(replyTo: ActorRef[Ping]) extends Message
        \`\`\`
        
        ### Service Discovery
        \`\`\`scala
        // Service keys for actor registration
        val PingServiceKey: ServiceKey[Message] = ServiceKey[Message]("pingService")
        val PongServiceKey: ServiceKey[Message] = ServiceKey[Message]("pongService")
        \`\`\`
        
        ## Architecture Overview
        
        ### Node1 (Primary)
        - **Role**: Ping service provider
        - **Port**: 2555
        - **Responsibility**: Initiates ping-pong cycles and manages primary cluster coordination
        
        ### Node2 (Secondary)  
        - **Role**: Pong service provider
        - **Port**: 2551
        - **Responsibility**: Responds to ping messages and provides secondary cluster services
        
        ## Usage Examples
        
        ### Registering a Service
        \`\`\`scala
        import org.example.api.discovery.ServiceKeys
        import akka.actor.typed.receptionist.Receptionist
        
        // Register ping service (Node1)
        context.system.receptionist ! Receptionist.Register(
          ServiceKeys.PingServiceKey, 
          context.self
        )
        
        // Register pong service (Node2)
        context.system.receptionist ! Receptionist.Register(
          ServiceKeys.PongServiceKey, 
          context.self
        )
        \`\`\`
        
        ### Discovering and Using Services
        \`\`\`scala
        import org.example.api.protocol.{Ping, Pong}
        
        // Node1: Send a ping message
        pongService ! Ping(context.self)
        
        // Node2: Handle ping and respond with pong
        case Ping(replyTo) =>
          println("Ping received")
          replyTo ! Pong(context.self)
        
        // Node1: Handle pong response
        case Pong(replyTo) =>
          println("Pong received")
          replyTo ! Ping(context.self)
        \`\`\`
        
        ## Navigation Tips
        
        - **For API Users**: Start with [Shared Public API](./shared/) documentation
        - **For Implementers**: Review both [Node1](./node1/) and [Node2](./node2/) specific docs
        - **For Migration**: Check version-specific changes in each node's documentation
        
        ---
        
        *This documentation is automatically generated from the source code and represents both the stable public API and node-specific implementations.*
        EOF
        
        # Create individual index pages for each node
        if [ "$NODE1_GENERATED" = true ]; then
          cat > api/v${{ steps.version.outputs.major_version }}/scala/node1/README.md << EOF
        # Node1 (Primary) - Scala API Documentation
        
        **Version:** ${{ steps.version.outputs.version }}  
        **Node Role:** Primary cluster node (Ping service provider)  
        **Port:** 2555
        
        ## Overview
        
        This documentation covers the Node1-specific implementation of the Akka cluster.
        Node1 serves as the primary cluster node and implements the Ping service.
        
        ## Key Files
        
        - **App.scala** - Main application and cluster coordination
        - **WorkerTwo.scala** - Primary worker actor implementation
        - **Public API** - Shared message protocol and service keys
        
        ## Browse Documentation
        
        - [Browse Scaladoc](./index.html) - Complete Node1 API reference
        - [Package Index](./package.html) - Package overview
        - [Back to Overview](../index.html) - Return to main Scala API docs
        
        ## Node1 Responsibilities
        
        - Initialize Docker Swarm as manager node
        - Provide Ping service to the cluster
        - Coordinate cluster formation and management
        - Handle primary actor system configuration
        EOF
        fi
        
        if [ "$NODE2_GENERATED" = true ]; then
          cat > api/v${{ steps.version.outputs.major_version }}/scala/node2/README.md << EOF
        # Node2 (Secondary) - Scala API Documentation
        
        **Version:** ${{ steps.version.outputs.version }}  
        **Node Role:** Secondary cluster node (Pong service provider)  
        **Port:** 2551
        
        ## Overview
        
        This documentation covers the Node2-specific implementation of the Akka cluster.
        Node2 serves as a secondary cluster node and implements the Pong service.
        
        ## Key Files
        
        - **App.scala** - Secondary node application logic
        - **WorkerOne.scala** - Secondary worker actor implementation
        - **Public API** - Shared message protocol and service keys
        
        ## Browse Documentation
        
        - [Browse Scaladoc](./index.html) - Complete Node2 API reference
        - [Package Index](./package.html) - Package overview
        - [Back to Overview](../index.html) - Return to main Scala API docs
        
        ## Node2 Responsibilities
        
        - Join Docker Swarm as worker node
        - Provide Pong service to the cluster
        - Respond to ping messages from Node1
        - Handle secondary actor system configuration
        EOF
        fi
        
        # Create shared API index
        if [ "$NODE1_GENERATED" = true ] || [ "$NODE2_GENERATED" = true ]; then
          cat > api/v${{ steps.version.outputs.major_version }}/scala/shared/README.md << EOF
        # Shared Public API - Scala Documentation
        
        **Version:** ${{ steps.version.outputs.version }}  
        **Scope:** Public API shared between all cluster nodes
        
        ## Overview
        
        This documentation covers the **public API** that is shared between Node1 and Node2.
        These are the stable interfaces that external applications can depend on.
        
        ## Public Packages
        
        - **org.example.api.protocol** - Message protocol definitions
        - **org.example.api.discovery** - Service discovery keys
        
        ## Browse Documentation
        
        - [Browse Scaladoc](./index.html) - Complete public API reference
        - [Package Index](./package.html) - Package overview
        - [Back to Overview](../index.html) - Return to main Scala API docs
        
        ## API Stability
        
        All classes and interfaces in this documentation are part of the **public API**.
        Changes to these interfaces follow semantic versioning:
        
        - **MAJOR**: Breaking changes to public interfaces
        - **MINOR**: Backward compatible additions
        - **PATCH**: Bug fixes and internal improvements
        EOF
        fi
        
        # Generate summary
        echo "ðŸ“š Scaladoc generation completed:"
        echo "  - Node1: $( [ "$NODE1_GENERATED" = true ] && echo "âœ… Success" || echo "âŒ Failed" )"
        echo "  - Node2: $( [ "$NODE2_GENERATED" = true ] && echo "âœ… Success" || echo "âŒ Failed" )"
        echo "  - Shared API: $( [ "$NODE1_GENERATED" = true ] || [ "$NODE2_GENERATED" = true ] && echo "âœ… Generated" || echo "âŒ Failed" )"

    - name: Extract Docker API Documentation
      run: |
        # Install yq for YAML parsing
        sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
        sudo chmod +x /usr/local/bin/yq
        
        cat > api/v${{ steps.version.outputs.major_version }}/docker/index.md << EOF
        ---
        layout: default
        title: Docker Compose API v${{ steps.version.outputs.major_version }}
        ---
        
        # Docker Compose Public API v${{ steps.version.outputs.major_version }}
        
        **Version:** ${{ steps.version.outputs.version }}  
        **Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        
        ## API Overview
        
        This document describes the public interface for deploying the Akka cluster using Docker Compose.
        
        ## Public Services
        
        EOF
        
        # Create a summary table first
        echo "| Service | Ports | Networks |" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "|---------|-------|----------|" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        
        # Extract service information in a clean table format
        yq eval '.services | keys | .[]' docker-compose.yml | while read -r service; do
          # Get ports (only the exposed ones)
          PORTS=$(yq eval ".services.${service}.ports // []" docker-compose.yml | grep -E "^\s*-" | sed 's/^.*"\([^"]*\)".*/\1/' | tr '\n' ', ' | sed 's/,$//')
          if [ -z "$PORTS" ]; then
            PORTS="none"
          fi
          
          # Get networks
          NETWORKS=$(yq eval ".services.${service}.networks // []" docker-compose.yml | grep -v "null" | tr '\n' ', ' | sed 's/,$//' | sed 's/^- //')
          if [ -z "$NETWORKS" ] || [ "$NETWORKS" = "null" ]; then
            NETWORKS="default"
          fi
          
          echo "| **$service** | \`$PORTS\` | \`$NETWORKS\` |" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        done
        
        # Add detailed sections for each service
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "## Service Details" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        
        yq eval '.services | keys | .[]' docker-compose.yml | while read -r service; do
          echo "### $service" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          
          # Extract only essential information
          echo "**Configuration:**" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          
          # Ports
          PORTS=$(yq eval ".services.${service}.ports // []" docker-compose.yml)
          if [ "$PORTS" != "null" ] && [ "$PORTS" != "[]" ]; then
            echo "- **Ports:** \`$(echo "$PORTS" | grep -E "^\s*-" | sed 's/^.*"\([^"]*\)".*/\1/' | tr '\n' ',' | sed 's/,$//')\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          fi
          
          # Networks
          NETWORKS=$(yq eval ".services.${service}.networks // []" docker-compose.yml)
          if [ "$NETWORKS" != "null" ] && [ "$NETWORKS" != "[]" ]; then
            echo "- **Networks:** \`$(echo "$NETWORKS" | tr '\n' ',' | sed 's/,$//' | sed 's/^- //')\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          fi
          
          # Container name
          CONTAINER_NAME=$(yq eval ".services.${service}.container_name // null" docker-compose.yml)
          if [ "$CONTAINER_NAME" != "null" ]; then
            echo "- **Container Name:** \`$CONTAINER_NAME\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          fi
          
          # Image (if not using build)
          IMAGE=$(yq eval ".services.${service}.image // null" docker-compose.yml)
          if [ "$IMAGE" != "null" ]; then
            echo "- **Image:** \`$IMAGE\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          fi
          
          echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        done
        
        # Add networks section with essential info only
        echo "## Networks" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        
        yq eval '.networks | keys | .[]' docker-compose.yml | while read -r network; do
          echo "### $network" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          
          # Driver
          DRIVER=$(yq eval ".networks.${network}.driver // null" docker-compose.yml)
          if [ "$DRIVER" != "null" ]; then
            echo "- **Driver:** \`$DRIVER\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          fi
          
          # Attachable
          ATTACHABLE=$(yq eval ".networks.${network}.attachable // null" docker-compose.yml)
          if [ "$ATTACHABLE" != "null" ]; then
            echo "- **Attachable:** \`$ATTACHABLE\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
          fi
          
          echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        done
        
        # Add environment variables section
        echo "## Required Environment Variables" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "| Variable | Description | Example |" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "|----------|-------------|---------|" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "| \`JOIN_TOKEN\` | Docker Swarm worker join token | \`SWMTKN-1-...\` |" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "| \`MANAGER_IP\` | Docker Swarm manager IP address | \`192.168.1.100\` |" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        
        # Add usage example
        echo "## Usage Example" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "\`\`\`bash" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "# Set required environment variables" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "export JOIN_TOKEN=\$(docker swarm join-token -q worker)" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "export MANAGER_IP=\$(docker node inspect self --format '{{.Status.Addr}}')" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "# Deploy the cluster" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "docker-compose up -d" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        echo "\`\`\`" >> api/v${{ steps.version.outputs.major_version }}/docker/index.md
        
        echo "ðŸ³ Docker API documentation generated with essential information only"

    - name: Create version-specific index
      run: |
        cat > api/v${{ steps.version.outputs.major_version }}/index.md << EOF
        ---
        layout: default
        title: API Documentation v${{ steps.version.outputs.major_version }}
        ---
        
        # Public API Documentation v${{ steps.version.outputs.major_version }}
        
        **Current Version:** ${{ steps.version.outputs.version }}  
        **Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        
        ## ðŸ“¨ Message Protocol API
        
        - [**Scala API Documentation**](./scala/) - Complete documentation for both nodes
          - [Shared Public API](./scala/shared/) - Common interfaces and protocols
          - [Node1 Implementation](./scala/node1/) - Primary cluster node (Ping service)
          - [Node2 Implementation](./scala/node2/) - Secondary cluster node (Pong service)
        
        ## ðŸ³ Deployment API
        
        - [**Docker Compose Interface**](./docker/) - Service configuration and networking
        
        ## ðŸ—ï¸ Architecture Overview
        
        This project implements a distributed Akka cluster with two specialized nodes:
        
        ### Node Architecture
        
        | Node | Role | Port | Service | Responsibility |
        |------|------|------|---------|----------------|
        | **Node1** | Primary | 2555 | Ping | Cluster coordination, ping initiation |
        | **Node2** | Secondary | 2551 | Pong | Message response, worker services |
        
        ### Communication Flow
        
        \`\`\`
        Node1 (Ping Service)  â†â†’  Node2 (Pong Service)
            â†“                           â†“
        ServiceKeys.PingServiceKey  ServiceKeys.PongServiceKey
            â†“                           â†“
        Receptionist Registration  Receptionist Registration
        \`\`\`
        
        ## ðŸ”„ Version History
        
        - [All API Versions](../index.html) - Browse historical API documentation
        - [Migration Guide](https://github.com/brunoesposito2/DockerSwarmAkka/releases) - Breaking changes between versions
        
        ## ðŸ“‹ Semantic Versioning
        
        This API follows [Semantic Versioning 2.0.0](https://semver.org/):
        
        | Version Component | When to Increment | Examples |
        |------------------|-------------------|----------|
        | **MAJOR** (breaking) | Incompatible changes | Message protocol changes, port changes, service renames |
        | **MINOR** (feature) | Backward compatible features | New message types, optional configurations |
        | **PATCH** (fix) | Backward compatible fixes | Bug fixes, documentation updates |
        
        ## ðŸš€ Quick Start
        
        ### 1. Using the Message Protocol
        
        \`\`\`scala
        import org.example.api.protocol.{Ping, Pong}
        import org.example.api.discovery.ServiceKeys
        
        // Register services (both nodes)
        context.system.receptionist ! Receptionist.Register(ServiceKeys.PingServiceKey, context.self)
        context.system.receptionist ! Receptionist.Register(ServiceKeys.PongServiceKey, context.self)
        
        // Send messages
        pingService ! Ping(context.self)
        pongService ! Pong(context.self)
        \`\`\`
        
        ### 2. Deploying with Docker Compose
        
        \`\`\`bash
        # Set required environment variables
        export JOIN_TOKEN=\$(docker swarm join-token -q worker)
        export MANAGER_IP=\$(docker node inspect self --format '{{.Status.Addr}}')
        
        # Deploy both nodes
        docker-compose up -d
        \`\`\`
        
        ### 3. Monitoring the Cluster
        
        \`\`\`bash
        # Check cluster status
        docker node ls
        
        # View service logs
        docker service logs akka_worker1
        docker service logs akka_worker2
        
        # Monitor ping-pong communication
        docker logs -f worker1
        docker logs -f worker2
        \`\`\`
        
        ## ðŸ“– Documentation Guide
        
        ### For API Users
        1. Start with [Shared Public API](./scala/shared/) for stable interfaces
        2. Review [Docker API](./docker/) for deployment configuration
        3. Check version compatibility in [Migration Guide](https://github.com/brunoesposito2/DockerSwarmAkka/releases)
        
        ### For Implementers
        1. Study [Node1](./scala/node1/) for primary node implementation patterns
        2. Review [Node2](./scala/node2/) for secondary node architecture
        3. Understand the complete flow in [Shared API](./scala/shared/)
        
        ### For DevOps
        1. Configure deployment using [Docker API](./docker/) documentation
        2. Set up monitoring based on service definitions
        3. Plan capacity using the architecture overview above
        
        ---
        
        *This documentation is automatically generated and represents the complete API surface for version ${{ steps.version.outputs.version }}*
        EOF

    - name: Update main API index
      run: |
        # Create or update main API index
        cat > api/index.md << EOF
        ---
        layout: default
        title: API Documentation
        ---
        
        # Akka Cluster Public API Documentation
        
        **Last Updated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        
        ## ðŸ“š API Versions
        
        EOF
        
        # List all version directories
        ls api/ 2>/dev/null | grep "^v[0-9]" | sort -V -r | while read version; do
          if [ -f "api/$version/index.md" ]; then
            echo "- [${version}](./${version}/) - Major version ${version#v}" >> api/index.md
          fi
        done
        
        cat >> api/index.md << EOF
        
        ## ðŸŽ¯ What's in the Public API
        
        - **Message Protocol**: Actor messages (\`Ping\`, \`Pong\`) and service discovery keys
        - **Deployment Interface**: Docker Compose service definitions, ports, and networking
        
        ## ðŸ“– Documentation Types
        
        - **Scala API**: Generated from source code comments (Scaladoc)
        - **Deployment API**: Extracted from Docker Compose configuration
        
        ## ðŸ”„ Versioning Strategy
        
        - **Each major version** gets its own documentation
        - **Breaking changes** increment the major version
        - **Historical versions** remain available for migration reference
        
        ## ðŸš€ Getting Started
        
        1. **Choose the latest version** for new projects
        2. **Review breaking changes** when upgrading between major versions  
        3. **Follow the migration guides** in the GitHub releases
        
        ---
        
        Generated automatically from [brunoesposito2/DockerSwarmAkka](https://github.com/brunoesposito2/DockerSwarmAkka) releases.
        EOF

    - name: Configure Git
      run: |
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"

    - name: Commit and push documentation
      run: |
        git add api/
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "docs: update API documentation for v${{ steps.version.outputs.version }}

        [skip ci]

        - Updated API documentation for version ${{ steps.version.outputs.version }}
        - Generated Scala API documentation for public packages
        - Updated Docker Compose API documentation
        - Auto-generated from semantic release"
          
          git push
          echo "Documentation updated and pushed to repository"
        fi

    - name: Summary
      run: |
        echo "## ðŸ“– API Documentation Generated Successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Major Version:** v${{ steps.version.outputs.major_version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“ Generated Documentation" >> $GITHUB_STEP_SUMMARY
        
        # Check which Scaladoc was generated
        NODE1_STATUS="âŒ"
        NODE2_STATUS="âŒ"
        if [ -d "api/v${{ steps.version.outputs.major_version }}/scala/node1" ] && [ "$(ls -A api/v${{ steps.version.outputs.major_version }}/scala/node1 2>/dev/null)" ]; then
          NODE1_STATUS="âœ…"
        fi
        if [ -d "api/v${{ steps.version.outputs.major_version }}/scala/node2" ] && [ "$(ls -A api/v${{ steps.version.outputs.major_version }}/scala/node2 2>/dev/null)" ]; then
          NODE2_STATUS="âœ…"
        fi
        
        echo "- $NODE1_STATUS **Node1 Scaladoc** - Primary cluster node documentation" >> $GITHUB_STEP_SUMMARY
        echo "- $NODE2_STATUS **Node2 Scaladoc** - Secondary cluster node documentation" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Shared API Documentation** - Public interfaces and protocols" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Docker Compose API** - Services, ports, and networks configuration" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Version-specific index** - Comprehensive API overview" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Main API index** - Historical versions and navigation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Access Documentation" >> $GITHUB_STEP_SUMMARY
        echo "- **Main Site**: https://brunoesposito2.github.io/DockerSwarmAkka/" >> $GITHUB_STEP_SUMMARY
        echo "- **API v${{ steps.version.outputs.major_version }}**: https://brunoesposito2.github.io/DockerSwarmAkka/api/v${{ steps.version.outputs.major_version }}/" >> $GITHUB_STEP_SUMMARY
        echo "- **Node1 Docs**: https://brunoesposito2.github.io/DockerSwarmAkka/api/v${{ steps.version.outputs.major_version }}/scala/node1/" >> $GITHUB_STEP_SUMMARY
        echo "- **Node2 Docs**: https://brunoesposito2.github.io/DockerSwarmAkka/api/v${{ steps.version.outputs.major_version }}/scala/node2/" >> $GITHUB_STEP_SUMMARY
        echo "- **Shared API**: https://brunoesposito2.github.io/DockerSwarmAkka/api/v${{ steps.version.outputs.major_version }}/scala/shared/" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Generation Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Documentation Structure**: Multi-node with shared API separation" >> $GITHUB_STEP_SUMMARY
        echo "- **Node1 (Primary)**: $( [ "$NODE1_STATUS" = "âœ…" ] && echo "Successfully generated" || echo "Generation failed" )" >> $GITHUB_STEP_SUMMARY
        echo "- **Node2 (Secondary)**: $( [ "$NODE2_STATUS" = "âœ…" ] && echo "Successfully generated" || echo "Generation failed" )" >> $GITHUB_STEP_SUMMARY
        echo "- **Docker API**: Essential configuration only (clean format)" >> $GITHUB_STEP_SUMMARY
        echo "- **Format**: Structured navigation with role-based documentation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŽ¯ Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Documentation committed to repository with [skip ci]" >> $GITHUB_STEP_SUMMARY
        echo "2. Jekyll will rebuild the site automatically" >> $GITHUB_STEP_SUMMARY
        echo "3. Both node-specific and shared API docs will be available" >> $GITHUB_STEP_SUMMARY
        echo "4. Users can navigate between implementations and public API" >> $GITHUB_STEP_SUMMARY